\section{Unser Programm}

\subsection{Die einzelnen Bereiche}

\subsubsection{Das neuronale Netz}
%Der Aufbau des Netzes, Funktionsweise von Backpropagtion

Ein neuronales Netz besteht aus Neuronen, ähnlich einem menschlichen Gehirn. Die
Neuronen sind in Schichten angeordnet, den Layern des Netzes. Das erste Layer
ist dabei das Input Layer, das letzte das Output Layer. Zwischen den Layern
gehen Kanten von jedem Neuron des einen zu jedem Neuron des anderen Layers.
Diese Kanten haben Gewichte und pro Layer gibt es auch einen Bias, der zum
Kantengewicht addiert wird. Ein Signal wird durch das Input Layer aufgenommen,
durch die Layer weitergegeben und vom Output Layer wieder ausgegeben. Das
Weiterleiten innerhalb des Netzes funktioniert über die Kanten. Der Output eines
Neurons ist die Summe aller seiner Eingänge. Durch eine Sigmoidfunktion, hier
$\frac{1}{1 + e^{-x}}$, werden diese Summen auf den Wertebereich $[-1;1]$
reduziert und gleichzeitig ermöglicht diese Funktion die spätere Anwendung des
Backpropagation Algorithmus, da sie differenzierbar ist. Der fertige Output des
Neurons wird dann mit den jeweiligen Kantengewichten multipliziert und an die
Neuronen des nächsten Layers weitergeleitet. Vor allem hier ist also sehr viel
zu Berechnen. 

Der Aufbau der Netze ist variabel, die Anzahl der Layer sowie die Anzahl der
Neuronen pro Layer ist frei wählbar. Das Input Layer sollte allerdings für jeden
Schnittpunkt des Eingabebrettes ein Neuron haben und das Output Layer
entsprechend ein Neuron pro Schnittpunkt plus ein Neuron um Passen anzuzeigen.
Die Ausgabe sind die Präferenzen der Netze, der Schnittpunkt mit dem höchsten
Wert wird besetzt. 

Damit die Netze zumindest die Regeln von vornherein erlernen, gibt es eine
Methode für Supervised Learning, überwachtes Lernen, den Backpropagation
Algorithmus. Für ihn muss bekannt sein, was das erwartete Ergebnis ist, weswegen
die Netze so nur auf die Go Regeln und nicht auf die Taktik trainiert werden
können. Der Algorithmus basiert darauf, dass der tatsächliche Ausgabewert mit
dem erwarteten Wert verglichen wird und der so ermittelte Fehler zur Korrektur
der Kantengewichte benutzt wird. Um die richtigen Korrekturwerte für die
einzelnen Layer zu erhalten, muss die Ableitung der Fehlerfunktion durch die
Ableitung des Kantengewichts berechnet werden. Dazu summiert man die
Fehlersignale der vorhergehenden Schicht mal dem dazugehörigen Kantengewicht auf
und multipliziert es mit der Ausgabe des Neurons. So wird nur der Teil des
Fehlers, der tatsächlich von diesem Neuron verursacht wurde, korrigiert. 

\subsubsection{Go}
%Welche Komponenten? Wie spielt es zusammen?

Die Implementation des Go Spiels besteht aus mehreren Komponenten. Zunächst sind
die Spielregeln und grundlegenden Aktionen im Spiel, wie etwa zu passen oder
einen Stein zu legen, in board.h, also dem Go Brett, implementiert. Das Brett
ist darin ein eigener Datentyp, der unter anderem den aktuellen Stand des
Spieles, etwa welcher Spieler an der Reihe ist oder ob ein Ko vorliegt, und alle
existierenden Gruppen von Steinen inklusive deren Freiheiten speichert. Die
Gruppen sind deshalb wichtig, weil sie beim Schlagen eines Steins berücksichtigt
werden müssen; wären sie nicht gespeichert, müssten sie in jedem Zug in dem
Gebiet um den neuen Stein berechnet werden, was relativ zeitaufwändig wäre. Es
ist also, vor allem da wir unseren Fokus auf kleinere Netze gelegt haben,
sinnvoll die Steingruppen zu speichern. 

Während im Brett die meisten Regeln implementiert sind, kann es nicht
selbstständig den Spielablauf regeln. Dafür wird game.h benutzt, worin ein Spiel
für eine bestimmte Brettgröße und zwei Spieler erstellt wird und Schritt für
Schritt gespielt werden kann. Die Spieler sind in player.h definiert und können
sowohl Menschen als auch neuronale Netze sein. So muss im eigentlichen Spiel
nicht mehr auf die Funktionen des neuronalen Netz zurückgegriffen werden, da die
Züge über den erstellten Spieler abgefragt werden. Im Spiel kann außerdem ein
Zuglimit gesetzt werden, für den Fall dass etwa eine Endlosschleife auftritt
oder die Spiele besonders kurz gehalten werden sollen. 

Um die Spiele nachträglich zu analysieren, gibt es die Möglichkeit sie
aufzuzeichnen. Dabei können zwei Formate benutzt werden: zum einen ASCII-Art,
zum anderen SGF. ASCII-Art kann natürlich ohne zusätzliche Software sofort
genutzt werden, um die SGF Dateien sinnvoll zu nutzen wird aber ein geeignetes
Programm benötigt. Viele Go Programme etwa sind in der Lage SGF Dateien
einzulesen und dann Zug für Zug darzustellen. 

\subsubsection{Der genetische Algorithmus}
%Wie funktioniert er?

Der genetische Algorithmus imitiert die Evolution um die Spielstärke der
neuronalen Netze zu verbessern. Entsprechend wird auch Terminologie aus der
Biologie übernommen: Population, Genom, Mutation, Generation, Fitness. Eine
Generation bezeichnet dabei eine Abfolge von Spielen und die Selektion und
Mutation der Population. Die Anzahl dieser Generationen wird anfangs festgelegt.

Jedes Netz hat einen bestimmten Fitnesswert, der der Anzahl der gewonnen Spiele
entspricht. Sein Genom bilden alle seine Kantengewichte. Alle gegeneinander
spielenden Netze zusammen sind eine Population. Soll diese Population eine
Generation voran gebracht werden, wird zunächst ausgewählt, welche Individuen in
die nächste Generation übernommen werden. Sie werden zufällig ausgesucht,
allerdings ist die Wahrscheinlichkeit ein Netz zu wählen proportional zu seinem
Fitnesswert. Ist ein Netz also besonders fit, wird es wahrscheinlicher in der
nächsten Generation auftauchen. Um keine guten Netze durch "Pech" bei der 
zufälligen Selektion zu verlieren, werden zusätzlich (in unserem Fall 4) Plätze 
in der nächsten Generation reserviert, die mit den unabgeänderten besten Netzen 
der letzten Generation gefüllt werden. Danach werden die Netze mutiert, 
ebenfalls zufällig. Es gibt eine bestimmte Mutationswahrscheinlichkeit, mit 
deren Hilfeüberprüft wird, ob ein bestimmtes Kantengewicht mutiert, also um einen
zufälligen Wert verändert werden soll, oder nicht. Für jedes Element des Genoms
wird eine Zufallszahl zwischen 0 und 1 erzeugt, ist sie kleiner als die
Mutationswahrscheinlichkeit, dann wird mutiert. Ist dieser Schritt abgeschlossen, 
ist die Population eine Generation fortgeschritten. Jetzt muss für jedes Netz 
wieder die Fitness durch Spiele gegen andere aktualisiert werden und der 
Algorithmus fängt wieder von vorne an.

\subsection{Die Tools}
%Welche gibt es? Wie setzt man sie ein? Warum macht das so Sinn?
Wie funktioniert nun Nugengo? Es besteht aus mehreren Command Line Tools, die
folgende Funktionen abdecken:
\begin{itemize}
\item Erstellung und Regeltraining (backpropagation) von Netzen
\item Training von Netzen (genetischer Algorithmus)
\item Auswertung von Netzen gegeneinander
\item Ausführung von Mensch-gegen-Netz-Spielen
\end{itemize}
Im Allgemeinen sieht die vorgesehene Nutzung also so aus: zuerst werden Netze
erstellt und mit Trainingsdaten trainiert. Nun hat man eine Grundlage, von der
aus man die Netze beliebig oft und lange durch den genetischen Algorithmus
trainieren kann. Dazwischen kann durch Spiele gegen den Nutzer oder andere, 
eventuell schon trainierte Netze, eine Art Zwischenstand abgefragt werden. Am Ende 
kann so auch die Spielstärke des Netzes ermittelt werden und die Netze gespeichert 
werden. Das Ergebnis ist das eine Datei, von der aus man ein sehr gut trainiertes 
Netz immer wieder aufrufen kann, etwa um Spiele durchzuführen oder es noch weiter 
zu verbessern.
